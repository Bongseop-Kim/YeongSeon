# ADR 0001: 읽기 = View, 쓰기 = RPC

상태: 승인됨

## 배경

프로젝트에서 DB 뷰와 클라이언트 쿼리 빌더 호출로 표현 가능한 읽기 요구에도 RPC 사용이 늘어나 API 표면과 유지비가 증가했다.

쓰기 요구(주문 생성, 장바구니 교체, 클레임 생성)는 트랜잭션 무결성, 소유권 검증, 서버 계산이 필요해 테이블 직접 쓰기 방식으로는 안전하지 않았다.

## 결정

다음 아키텍처 규칙을 채택한다:

- **읽기 경로**: DB View + API 레이어에서 `from().select()` 사용.
- **쓰기 경로**: 트랜잭션 영속화는 쓰기 RPC에서 수행한다.
- **쓰기 진입점**: 유스케이스별로 Edge 또는 직접 RPC를 사용한다.
  - 주문 생성: `클라이언트 -> create-order Edge -> create_order_txn`
  - 장바구니 교체: `클라이언트 -> replace_cart_items` (직접 RPC)
  - 클레임 생성: `클라이언트 -> create_claim` (직접 RPC)
  - 장바구니 초기화: `클라이언트 -> cart_items DELETE` (직접 테이블 쓰기, RLS 기반 예외)

추가 제약:

1. UI와 DTO는 분리 유지 (Option B).
2. 매핑은 API mapper 파일에서만 수행.
3. 뷰 + 쿼리 빌더로 충분한 경우 읽기 RPC 사용 금지.
4. 쓰기 RPC는 명시적 보안 모드와 소유권 검증(`auth.uid()`)을 선언해야 한다.
5. 금액/할인/합계는 서버(RPC)에서 계산한다.
6. 직접 테이블 쓰기는 RLS로 완전 보호되는 단순 동작에 한해 예외적으로 허용한다.

## 결과

긍정적:

- 읽기 사용 사례에 대한 RPC 표면 축소.
- 뷰를 통한 읽기 모델 탐색성 향상.
- 기능별 API 레이어와 매퍼 경계 명확화.

트레이드오프:

- 설계상 두 가지 패턴이 공존 (읽기는 View, 쓰기는 RPC).
- 쓰기 진입점이 혼합되어 코드 리뷰 시 경로별 요건(Edge 검증 vs RPC 자체 검증) 확인이 필요.

## 적용된 변경 사항

- 상품 읽기를 `product_list_view`로 전환.
- 주문 읽기를 `order_list_view` + `order_item_view`로 전환.
- `get_products`, `get_product_by_id`, `get_products_by_ids` 읽기 RPC의 클라이언트 사용 제거.
- `get_orders`, `get_order` 읽기 RPC의 클라이언트 사용 제거.
- 주문 생성은 `create-order` Edge 진입점을 유지.
- 장바구니/클레임 쓰기는 RPC 직접 호출 + RPC 내부 소유권/무결성 검증으로 운영.
- 장바구니 초기화는 `cart_items` 직접 삭제 경로를 유지(RLS 제약 기반).

## 비목표

- 모든 쓰기 흐름을 즉시 Edge 전용으로 재구성하는 작업.
- 기존 쓰기 RPC에 대한 즉시 권한 모델 전면 개편.

## 후속 작업

1. 엄격한 Edge 전용 계약이 필요해지면 장바구니/클레임도 Edge 경유로 단계적 전환.
2. 더 이상 참조되지 않는 레거시 읽기 객체 제거 (`get_orders`, `get_order`, 레거시 `order_items_view`).
